#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
from cm_modules.personality.custom.visuals import printc

# DO NOT import modules.definitions in root-dir files.
from definitions import MODULES_INTERNAL_PATH, ROOT_DIR_NAME, PYTHON_COMMAND

try:
    from cm_modules.internal.monk_helpers import handle_alternate_functionality
    from cm_modules.internal.find_script import find_script
    from cm_modules.internal.environment_checks import environment_checks
    from cm_modules.internal.utils.symlinks import verify_or_create_symlink
except ImportError:
    printc(" CodeMonkeys modules not imported correctly. Troubleshoot (#add link)'.", 'error')
    exit(1)

verify_or_create_symlink(os.path.abspath('definitions.py'), os.path.abspath('cm_modules/definitions.py'), output=False)
environment_checks()

# Create argument parser - use custom help
parser = argparse.ArgumentParser(add_help=False)
# Flags
parser.add_argument('-v', '--version', action='store_true')
parser.add_argument('-h', '--help', action='store_true')
# Flags - mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument('-e', '--edit', action='store_true')
group.add_argument('-p', '--print', action='store_true')
group.add_argument('-cp', '--copy_path', action='store_true',
                   help='Copy the absolute path of the script to the clipboard')
group.add_argument('-cc', '--copy_contents', action='store_true')
# Command or script name
parser.add_argument('command_or_script_name', nargs='?')

args = parser.parse_args()
flag_args_present = any([arg.startswith('-') for arg in sys.argv[1:]])


# If the user is not running the script (using the other flags), do not do warn them about the setup script
if args.command_or_script_name in ['install'] and flag_args_present is False:
    answer = input(
        "You are about to run install with the monk command. If you can run the monk command you likely have "
        f"already installed {ROOT_DIR_NAME}, and running this script may not be a good idea because it is not designed "
        "to handle post-install edge cases. This is not suggested. Are you sure you want to continue? (y/n): ")
    if answer.lower() == 'y':
        printc("ðŸš€ Starting the setup... Hang tight! ðŸŒŸ")
    else:
        if answer.lower() == 'n':
            printc("ðŸš€ Aborting setup...", 'done')
            sys.exit(0)
        else:
            printc("Invalid input. Aborting setup...", 'error')
        sys.exit(1)

# Special Commands
if args.command_or_script_name == 'check-definitions':
    printc("Verifying definitions.py symlink and ...", 'link')
    subprocess.call([PYTHON_COMMAND, os.path.join(MODULES_INTERNAL_PATH, 'check_definitions.py')])
    sys.exit(0)


# Detect `monk -h` and `monk --help`
if args.command_or_script_name is None and (args.help is True):
    args.command_or_script_name = 'help'

# If command_or_script_name doesn't match a command defined above, it's a script
script_path = find_script(args.command_or_script_name)

# Handle flags that do something other than run the script (edit, copy path, etc)
if handle_alternate_functionality(args, script_path):
    printc("ðŸš€ Done!", 'done')
    sys.exit(0)

# Check for flags that modify how the script is run
# TODO

# Get the extension of the script
extension = os.path.splitext(script_path.strip())[1]

# Run the script with the provided arguments
if extension == ".sh":
    subprocess.call(['bash', script_path.strip()] + sys.argv[2:])
elif extension == ".bat":
    subprocess.call([script_path.strip()] + sys.argv[2:])
elif extension == ".py":
    subprocess.call([sys.executable, script_path.strip()] + sys.argv[2:])
else:
    printc(f"Unsupported script type: {extension}", 'error')
    sys.exit(1)
