#!/usr/bin/env python3

import argparse
import fileinput
import os
import subprocess
import sys
from termcolor import colored

from definitions import ROOT_PATH, ROOT_DIR_NAME, PSEUDO_PACKAGE_PATH

try:
    from code_monkeys.modules.internal.monk_helpers import handle_alternate_functionality
    from code_monkeys.modules.internal.find_script import find_script
    from code_monkeys.modules.internal.monk_environment_checks import monk_environment_checks
except ImportError:
    print(colored("‚ö†Ô∏è  CodeMonkeys must be 'installed'. Run `setup.py`.", 'red'))
    exit(1)

monk_environment_checks()

# Write the contents of definitions.py to PSEUDO_PACKAGE_PATH/definitions.py (always)
# This will make sure on any script run that the definitions in the pseudo-package are up to date
with open(os.path.join(ROOT_PATH, 'definitions.py'), 'r') as f:
    definitions_contents = f.read()
docstring = f"""
# this file mimics the outer definitions.py file because CodeMonkeys uses a unique pseudo-package structure
# for namespacing global imports, we need it at the root and in the pseudo-package.
# It is rewritten every time the monk command is run, so you can easily re-generate it with `monk`

# do
# NOT
# edit
# this
# file, unless you're really changing things up in the extreme
"""
with open(os.path.join(PSEUDO_PACKAGE_PATH, 'definitions.py'), 'w') as f:
    f.write(definitions_contents)
# We need to replace the ROOT_PATH line in the pseudo-package with one that will get the correct path
# This will trickle down to all other PATH variables. This means only the root definitions.py needs to be updated
# as long as any updates to the root definitions.py do not depend on paths that are not based on the ROOT_PATH
new_root_path_line = "ROOT_PATH = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n"

# Open the file and replace the line
with fileinput.FileInput(os.path.join(PSEUDO_PACKAGE_PATH, 'definitions.py'), inplace=True) as file:
    for line in file:
        # Replace lines that start with 'ROOT_PATH' with the new line
        if line.startswith('ROOT_PATH'):
            line = new_root_path_line
        print(line, end='')

# Create argument parser - use custom help
parser = argparse.ArgumentParser(add_help=False)
# Flags
parser.add_argument('-v', '--version', action='store_true')
parser.add_argument('-h', '--help', action='store_true')
# Flags - mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument('-e', '--edit', action='store_true')
group.add_argument('-p', '--print', action='store_true')
group.add_argument('-cp', '--copy_path', action='store_true',
                   help='Copy the absolute path of the script to the clipboard')
group.add_argument('-cc', '--copy_contents', action='store_true')
# Command or script name
parser.add_argument('command_or_script_name', nargs='?')

args = parser.parse_args()
flag_args_present = any([arg.startswith('-') for arg in sys.argv[1:]])

if args.command_or_script_name is None and (args.help is True):
    args.command_or_script_name = 'help'

# If the user is not running the script (using the other flags), do not do warn them about the setup script
if args.command_or_script_name in ['install'] and flag_args_present is False:
    answer = input(
        "‚ö†Ô∏è You are about to run install with the monk command. If you can run the monk command you likely have "
        f"already installed {ROOT_DIR_NAME}, and running this script may not be a good idea because it is not designed "
        "to handle post-install edge cases. This is not suggested. Are you sure you want to continue? (y/n): ")
    if answer.lower() == 'y':
        print("üöÄ Starting the setup... Hang tight! üåü")
    else:
        if answer.lower() == 'n':
            print("üöÄ Aborting setup... üåü")
            sys.exit(0)
        else:
            print("Invalid input. Aborting setup... üåü")
        sys.exit(1)


# If command_or_script_name doesn't match a command defined above, it's a script
script_path = find_script(args.command_or_script_name)

# Handle flags that do something other than run the script (edit, copy path, etc)
if handle_alternate_functionality(args, script_path):
    sys.exit(0)

# Check for flags that modify how the script is run
# TODO

# Get the extension of the script
extension = os.path.splitext(script_path.strip())[1]

# Run the script with the provided arguments
if extension == ".sh":
    subprocess.call(['bash', script_path.strip()] + sys.argv[2:])
elif extension == ".bat":
    subprocess.call([script_path.strip()] + sys.argv[2:])
elif extension == ".py":
    subprocess.call([sys.executable, script_path.strip()] + sys.argv[2:])
else:
    print(f"‚ö†Ô∏è Unsupported script type: {extension}")
    sys.exit(1)
