#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
from termcolor import colored

from definitions import ROOT_DIR_NAME

try:
    from code_monkeys.modules.internal.monk_helpers import handle_alternate_functionality
    from code_monkeys.modules.internal.find_script import find_script
    from code_monkeys.modules.internal.monk_environment_checks import monk_environment_checks
except ImportError:
    print(colored("‚ö†Ô∏è  CodeMonkeys must be 'installed'. Run `setup.py`.", 'red'))
    exit(1)

monk_environment_checks()

# Create argument parser - use custom help
parser = argparse.ArgumentParser(add_help=False)
# Flags
parser.add_argument('-v', '--version', action='store_true')
parser.add_argument('-h', '--help', action='store_true')
# Flags - mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument('-e', '--edit', action='store_true')
group.add_argument('-p', '--print', action='store_true')
group.add_argument('-cp', '--copy_path', action='store_true',
                   help='Copy the absolute path of the script to the clipboard')
group.add_argument('-cc', '--copy_contents', action='store_true')
# Command or script name
parser.add_argument('command_or_script_name', nargs='?')

args = parser.parse_args()
flag_args_present = any([arg.startswith('-') for arg in sys.argv[1:]])

if args.command_or_script_name is None and (args.help is True):
    args.command_or_script_name = 'help'

# If the user is not running the script (using the other flags), do not do warn them about the setup script
if args.command_or_script_name in ['install'] and flag_args_present is False:
    answer = input(
        "‚ö†Ô∏è You are about to run install with the monk command. If you can run the monk command you likely have "
        f"already installed {ROOT_DIR_NAME}, and running this script may not be a good idea because it is not designed "
        "to handle post-install edge cases. This is not suggested. Are you sure you want to continue? (y/n): ")
    if answer.lower() == 'y':
        print("üöÄ Starting the setup... Hang tight! üåü")
    else:
        if answer.lower() == 'n':
            print("üöÄ Aborting setup... üåü")
            sys.exit(0)
        else:
            print("Invalid input. Aborting setup... üåü")
        sys.exit(1)


# If command_or_script_name doesn't match a command defined above, it's a script
script_path = find_script(args.command_or_script_name)

# Handle flags that do something other than run the script (edit, copy path, etc)
if handle_alternate_functionality(args, script_path):
    sys.exit(0)

# Check for flags that modify how the script is run
# TODO

# Get the extension of the script
extension = os.path.splitext(script_path.strip())[1]

# Run the script with the provided arguments
if extension == ".sh":
    subprocess.call(['bash', script_path.strip()] + sys.argv[2:])
elif extension == ".bat":
    subprocess.call([script_path.strip()] + sys.argv[2:])
elif extension == ".py":
    subprocess.call([sys.executable, script_path.strip()] + sys.argv[2:])
else:
    print(f"‚ö†Ô∏è Unsupported script type: {extension}")
    sys.exit(1)
